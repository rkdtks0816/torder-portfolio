import { Post } from "@/shared/interfaces/post";
import { tags } from "../BlogTags";

const post: Post = {
  title: `명령어`,
  time: "241119_3",
  tags: [tags.computerArchitecture],
  content: `
        ## 일해라 + 컴퓨터!
        > 연산코드 + 오퍼랜드

        - 오퍼랜드: 데이터 저장 위치
        - 연산코드
        
            | **분류**        | **연산 코드**       | **설명**                                                                                              | **예시**                    |
            |------------------|---------------------|------------------------------------------------------------------------------------------------------|-----------------------------|
            | **데이터 전송** | \`MOV\`               | 데이터 복사. 레지스터, 메모리, 즉시값 간의 데이터 이동.                                                | \`MOV AX, BX\` (AX ← BX)      |
            |                  | \`PUSH\` / \`POP\`     | 스택에 데이터를 저장(\`PUSH\`)하거나 꺼냄(\`POP\`).                                                        | \`PUSH AX\`, \`POP BX\`         |
            |                  | \`LOAD\` / \`STORE\`   | 메모리에서 레지스터로 데이터 로드(\`LOAD\`), 레지스터에서 메모리로 저장(\`STORE\`).                          | \`LOAD R1, 0x1000\`           |
            |                  | \`LEA\`              | 메모리 주소 계산 및 로드.                                                                             | \`LEA DX, [BX+SI]\`           |
            | **산술 연산**   | \`ADD\`               | 두 값을 더함.                                                                                        | \`ADD AX, BX\` (AX ← AX + BX) |
            |                  | \`SUB\`               | 두 값을 뺌.                                                                                          | \`SUB AX, BX\` (AX ← AX - BX) |
            |                  | \`MUL\` / \`DIV\`      | 곱셈(\`MUL\`), 나눗셈(\`DIV\`).                                                                           | \`MUL AX\`                    |
            |                  | \`INC\` / \`DEC\`      | 값을 1 증가(\`INC\`), 1 감소(\`DEC\`).                                                                    | \`INC AX\`, \`DEC BX\`          |
            | **논리 연산**   | \`AND\`               | 비트 단위로 AND 연산.                                                                                 | \`AND AX, BX\`                |
            |                  | \`OR\`                | 비트 단위로 OR 연산.                                                                                  | \`OR AX, BX\`                 |
            |                  | \`XOR\`               | 비트 단위로 XOR 연산.                                                                                 | \`XOR AX, BX\`                |
            |                  | \`NOT\`               | 비트를 반전.                                                                                         | \`NOT AX\`                    |
            |                  | \`SHL\` / \`SHR\`      | 비트를 왼쪽으로 이동(\`SHL\`), 오른쪽으로 이동(\`SHR\`).                                                   | \`SHL AX, 1\`                 |
            | **제어 흐름 변경** | \`JMP\`               | 무조건적인 분기.                                                                                      | \`JMP 0x200\`                 |
            |                  | \`JE\` / \`JNE\`       | 조건부 분기: 값이 같으면 점프(\`JE\`), 값이 다르면 점프(\`JNE\`).                                          | \`JE 0x300\`                  |
            |                  | \`CALL\` / \`RET\`     | 서브루틴 호출(\`CALL\`), 서브루틴에서 복귀(\`RET\`).                                                       | \`CALL FUNC\`, \`RET\`          |
            |                  | \`LOOP\`             | 반복 실행: 카운터 레지스터(\`CX\`) 값이 0이 될 때까지 점프.                                              | \`LOOP 0x400\`                |
            |                  | \`CMP\`              | 두 값을 비교. 조건부 점프와 함께 사용.                                                                 | \`CMP AX, BX\`                |
            | **입출력 제어** | \`IN\`                | 지정된 포트에서 데이터를 읽음.                                                                        | \`IN AL, 0x60\`               |
            |                  | \`OUT\`               | 지정된 포트로 데이터를 출력.                                                                          | \`OUT 0x60, AL\`              |
            |                  | \`HLT\`              | 시스템을 중지하거나 대기 상태로 전환.                                                                  | \`HLT\`                       |
            |                  | \`NOP\`              | 아무 작업도 하지 않음 (대기).                                                                          | \`NOP\`                       |
        
        ## 기계어 몰라 번역해줘!
        > 어셈블리어로 변역

        - 비교
            | **특성/기능**          | **CISC (Complex Instruction Set Computer)**                | **RISC (Reduced Instruction Set Computer)**                |
            |-----------------------|-----------------------------------------------------------|-----------------------------------------------------------|
            | **설계 철학**         | 복잡한 명령어를 포함하여 한 번에 많은 작업을 처리.           | 단순하고 적은 수의 명령어를 빠르게 실행.                   |
            | **명령어 수**         | 수백 개에서 수천 개.                                       | 수십 개에서 백여 개.                                       |
            | **명령어 구조**       | 다양한 길이의 명령어를 지원.                                | 고정 길이 명령어.                                           |
            | **명령어 처리 속도**  | 상대적으로 느림(복잡한 디코딩).                             | 매우 빠름(파이프라이닝 최적화).                             |
            | **주요 사용 사례**    | x86(인텔, AMD), VAX, IBM 메인프레임 등.                    | ARM, MIPS, RISC-V, PowerPC 등.                             |
            | **데이터 전송**       | \`MOV AX, [1000H]\` (메모리에서 레지스터로 이동)             | \`LW R1, 0(R2)\` (메모리에서 레지스터로 이동)               |
            | **산술 연산**         | \`ADD AX, BX\` (두 레지스터 덧셈)                            | \`ADD R1, R2, R3\` (두 레지스터 덧셈)                       |
            | **메모리 접근**       | \`ADD AX, [1000H]\` (메모리 값과 덧셈)                        | \`LW R1, 0(R2)\`<br>\`ADD R3, R1, R4\` (로드 후 계산)         |
            | **스택 연산**         | \`PUSH AX\` (레지스터 값을 스택에 저장)                       | \`SW R1, -4(SP)\`<br>\`ADDI SP, SP, -4\` (메모리 저장 후 스택 포인터 조정) |
            | **조건부 분기**       | \`JZ 0x100\` (값이 0이면 분기)                              | \`BEQ R1, R2, 0x100\` (값이 같으면 분기)                    |
            | **함수 호출**         | \`CALL 0x200\` (서브루틴 호출)                              | \`JAL 0x200\` (서브루틴 호출)                               |
            | **비트 연산**         | \`AND AX, BX\` (두 값의 비트 AND)                            | \`AND R1, R2, R3\` (두 값의 비트 AND)                       |
        
        ## 읽고 읽고 실행!
        > 명령어를 읽고 데이터를 읽고 실행

        - 인출 사이클: 명령어를 CPU로
        - 실행 사이클: CPU가 명령 실행
        - 간접 사이클: 데이터를 CPU로
        - 데이터가 필요없다면 간접 스킵
        
        \`\`\`
        이것이 취업을 위한 컴퓨터 과학이다 
        with CS 기술 면접을 기반으로 작성한 글입니다.
        \`\`\`
    `,
};

export default post;
